#!/usr/bin/env node
/* vim: set ft=javascript: */
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

/*
 * Copyright (c) 2017, Joyent, Inc.
 */

/*
 * mdshovel: stress-test for Manta metadata
 */

var mod_artedi = require('artedi');
var mod_assertplus = require('assert-plus');
var mod_bunyan = require('bunyan');
var mod_cmdutil = require('cmdutil');
var mod_fs = require('fs');
var mod_getopt = require('posix-getopt');
var mod_jsprim = require('jsprim');
var mod_libmanta = require('libmanta');
var mod_http = require('http');
var mod_path = require('path');
var mod_uuid = require('node-uuid');
var mod_vasync = require('vasync');
var VError = require('verror');

var mdsUsageMessage = [
    'Generates metadata according to specified configuration.'
].join('');

/*
 * This stress tester generates metadata similar to known workloads as follows:
 * for each operation (simulating an application-level operation), we generate a
 * uuid, then we create a directory for the operation under "largeDirectory",
 * and we create a tree of directories under "smallDirectoryRoot".  We complete
 * operations with concurrency "concurrency".
 */
var mdsConfigSchema = {
    'type': 'object',
    'properties': {
	'metadataService': {
	    'type': 'object',
	    'required': true,
	    'properties': {
		'srvDomain': {
		    'type': 'string',
		    'required': true
		},
		'cueballOptions': {
		    'type': 'object',
		    'required': true
		}
	    }
	},
	'concurrency': {
	    'type': 'number',
	    'required': true,
	    'minimum': 1,
	    'maximum': 10000
	},
	'largeDirectory': {
	    'type': 'string',
	    'required': true
	},
	'smallDirectoryRoot': {
	    'type': 'string',
	    'required': true
	},
	'artediPort': {
	    'type': 'number',
	    'required': true,
	    'minimum': 1,
	    'maximum': 65535
	}
    }
};

function main()
{
	var parser, option, argv;
	var log, cfgfile, dryrun;

	log = new mod_bunyan({
	    'name': 'mdshovel',
	    //'level': process.env['LOG_LEVEL'] || 'fatal'
	    'level': process.env['LOG_LEVEL'] || 'info'
	});

	mod_cmdutil.configure({
	    'synopses': [ 'CONFIG_FILE' ],
	    'usageMessage': mdsUsageMessage
	});

	dryrun = false;
	parser = new mod_getopt.BasicParser('n', process.argv);
	while ((option = parser.getopt()) !== undefined) {
		switch (option.option) {
		case 'n':
			dryrun = true;
			break;

		default:
			/* error message already emitted by getopt */
			mod_assertplus.equal('?', option.option);
			mod_cmdutil.usage();
			break;
		}
	}

	argv = process.argv.slice(parser.optind());
	if (argv.length != 1) {
		mod_cmdutil.usage('expected exactly one argument');
	}

	cfgfile = argv[0];
	mdsConfigLoadFromFile({
	    'log': log,
	    'dryRun': dryrun,
	    'filename': cfgfile
	}, function (err, mds) {
		if (err) {
			mod_cmdutil.fail(err);
		}

		mdsShovel(mds);
	});
}

/*
 * Given a filename in "args.filename", initializes program state based on the
 * configuration in that file.
 */
function mdsConfigLoadFromFile(args, callback)
{
	var log, filename, dryrun;

	mod_assertplus.object(args, 'args');
	mod_assertplus.string(args.filename, 'args.filename');
	mod_assertplus.object(args.log, 'args.log');
	mod_assertplus.bool(args.dryRun, 'args.dryRun');

	filename = args.filename;
	log = args.log;
	dryrun = args.dryRun;
	mod_fs.readFile(filename, function (err, filebytes) {
		var json, error, suffix;

		if (err) {
			callback(new VError(err, 'read "%s"', filename));
			return;
		}

		try {
			json = JSON.parse(filebytes.toString('utf8'));
		} catch (ex) {
			callback(new VError(ex, 'parse "%s"', filename));
			return;
		}

		//error = mod_jsprim.validateJsonObject(mdsConfigSchema, json);
		//if (error instanceof Error) {
			//callback(new VError(error, 'validate "%s"', filename));
			//return;
		//}

		callback(null, new Mds({
		    'filename': filename,
		    'dryRun': dryrun,
		    'log': log,
		    'configRaw': json
		}));
	});
}

/*
 * Stores the configuration and runtime state for the `mdshovel` operation.
 * By the time we call the constructor, the JSON must already have been
 * validated.
 */
function Mds(args)
{
	mod_assertplus.object(args, 'args');
	mod_assertplus.string(args.filename, 'args.filename');
	mod_assertplus.object(args.log, 'args.log');
	mod_assertplus.object(args.configRaw, 'args.configRaw');
	mod_assertplus.bool(args.dryRun, 'args.dryRun');

	/* static configuration */
	this.mds_config_filename = args.filename;
	this.mds_config_raw = args.configRaw;
	this.mds_max_concurrency = args.configRaw.concurrency;
	this.mds_port = args.configRaw.artediPort;
	this.mds_path_large = args.configRaw.largeDirectory;
	this.mds_path_small = args.configRaw.smallDirectoryRoot;
	this.mds_uuid_pfx = mod_path.basename(
	    this.mds_config_raw.largeDirectory);
	this.mds_dryrun = args.dryRun;

	/* runtime state */

	/* bunyan logger */
	this.mds_log = args.log;
	/* artedi collector */
	this.mds_artedi = mod_artedi.createCollector();
	/* http server for artedi */
	this.mds_server = null;
	/* metadata tier client (from libmanta) */
	this.mds_mdclient = null;
	/* timestamp when the metadata client became ready */
	this.mds_mdclient_ready = null;
	/* pending operations */
	this.mds_pending = {};

	/*
	 * Artedi-based metrics
	 */
	this.mds_c_nstarted = this.mds_artedi.counter({
	    'name': 'nstarted',
	    'help': 'count of composite operations started'
	});
	this.mds_c_ndone = this.mds_artedi.counter({
	    'name': 'ndone',
	    'help': 'count of composite operations completed ' +
		'(including failures)'
	});
	this.mds_c_nfail = this.mds_artedi.counter({
	    'name': 'nfail',
	    'help': 'count of composite operations that have failed'
	});
	this.mds_c_op_done = this.mds_artedi.counter({
	    'name': 'nopdone',
	    'help': 'count of discrete metadata operations finished'
	});

	this.mds_hist_op = this.mds_artedi.histogram({
	    'name': 'composite_latency_ms',
	    'help': 'latency of composite operations'
	});
	this.mds_hist_md = this.mds_artedi.histogram({
	    'name': 'md_latency_ms',
	    'help': 'latency of metadata operations'
	});

	/* simple counters */
    this.mds_c_nstarted.add(0);
    this.mds_c_ndone.add(0);
    this.mds_c_nfail.add(0);
	this.mds_nops_started = 0;	/* operations started */
	this.mds_nops_done = 0;		/* operations completed */
	this.mds_nops_fail = 0;		/* operations failed */
}

/*
 * Kicks off the `mdshovel` workload.
 */
function mdsShovel(mds)
{
	mod_assertplus.strictEqual(mds.mds_mdclient, null);

	mds.mds_log.info({
	    'configFilename': mds.mds_config_filename,
	    'configRaw': mds.mds_config_raw,
	    'dryRun': mds.mds_dryrun
	}, 'init');

	mds.mds_mdclient = mod_libmanta.createMorayClient({
	    'log': mds.mds_log.child({ 'component': 'libmanta.Moray' }),
	    'morayOptions': mds.mds_config_raw.metadataService
	});

	mds.mds_mdclient.on('error', function onMetadataClientError(err) {
		mod_cmdutil.fail(new VError(
		    err, 'fatal error from metadata client'));
	});

	mds.mds_mdclient.on('connect', function onMetadataClientConnect() {
		var i, max;

		mds.mds_mdclient_ready = new Date();
		//mds.mds_log.info('connected to the metadata tier');
		mds.mds_log.error('connected to the metadata tier');

		mdsArtediStart(mds, function (err) {
			if (err) {
				mod_cmdutil.fail(err);
			}

			mod_vasync.pipeline({
				funcs: [
					function (_, callback) {
						mdsCreateDirectory(mds, mod_uuid.v4(),
						    mds.mds_path_large, callback);
					},
					function (_, callback) {
						mdsCreateDirectory(mds, mod_uuid.v4(),
						    mds.mds_path_small, callback);
					}
				]
			}, function (err, _) {
				if (err) {
					mds.mds_log.error({
						err: err.message
					}, 'error create small/large path');
					process.exit(1);
				}
				mod_assertplus.notStrictEqual(mds.mds_mdclient, null);
				max = mds.mds_max_concurrency;
				mod_assertplus.number(max);
				mod_assertplus.ok(max > 0);
				for (i = 0; i < mds.mds_max_concurrency; i++) {
					mdsShovelOperation(mds);
				}
			});
		});
	});
}

/*
 * Completes one application-level operation, as described above.
 */
function mdsShovelOperation(mds)
{
	var op, uuid;

	/*
	 * The workload that we're simulating uses general uuids, but shards
	 * them over 16 metadata directories based on the first character of the
	 * uuid.  To reproduce the problem faster, we want to concentrate all of
	 * our work on one of these directories, as though all uuids started
	 * with the same letter.  Since we're faking up metadata anyway, it
	 * doesn't matter if our uuid really starts with that letter, but it
	 * will be a little less confusing this way.
	 */
	uuid = mod_uuid.v4();
	mod_assertplus.uuid(uuid);

	var base_dir = mod_path.join(mds.mds_path_large, mod_uuid.v4(),
	    mod_uuid.v4());
	var full_path = mod_path.join(base_dir, mod_uuid.v4());

	/* for dir creation */
	var dir_path = mod_path.join(mds.mds_path_small, mod_uuid.v4(),
	    mod_uuid.v4());

	op = {
	    'mp_base_dir': base_dir,
	    'mp_full_path': full_path,
	    'mp_dir_path': dir_path,
	    'mp_pipeline': null,
	    'mp_start_walltime': new Date(),
	    'mp_start_hrtime': process.hrtime(),
	    'mp_elapsed': null
	};

	mds.mds_pending[uuid] = op;
	mds.mds_nops_started++;
	mds.mds_c_nstarted.increment();
	mds.mds_log.debug({
	    'uuid': uuid,
	    'nstarted': mds.mds_nops_started,
	    'ndone': mds.mds_nops_done,
	    'nfailures': mds.mds_nops_fail
	}, 'beginning operation');


	/*
	 * Intended to simulate the Muskie getMetadata handler.
	 */
	function mdsOpResolveMetadata(path, uuid, cb) {
		var dirname = mod_path.dirname(path);
		/*
		 * We don't want to overload the primary with ROLLBACK requests,
		 * so we resolve the parent twice, instead of trying to resolve the
		 * (possibly non-existent) child.
		 */
		mod_vasync.parallel({
			funcs: [
				function (callback) {
					mdsGetObject(mds, uuid, dirname, callback);
				},
				function (callback) {
					mdsGetObject(mds, uuid, dirname, callback);
				}
			],
		},
		function (err, results) {
			cb(err);
		});
	}

	/*
	 * Simulates the metadata parts of a muskie putdirectory route.
	 */
	function mdsOpSimulatePutDirectory(path, uuid, cb) {
		mod_vasync.waterfall([
			function mdsGetMetadata(callback) {
				mdsOpResolveMetadata(path, uuid, callback);
			},
			function mdsDoPutdirectory(callback) {
				mdsCreateDirectory(mds, uuid, path, callback);	
			}
		], function (err, results) {
			cb(err);
		});
	}

	/*
	 * Simulates the metadata parts of a muskie putobject route.
	 */
	function mdsOpSimulatePutObject(path, uuid, cb) {
		var dirname = mod_path.dirname(path);
		mod_vasync.waterfall([
			function mdsGetMetadata(callback) {
				mdsOpResolveMetadata(path, uuid, callback);
			},
			function mdsDoPutobject(callback) {
				mdsCreateObject(mds, uuid, path, callback);
			},
			function mdsEnforceDirectoryCount(callback) {
				mdsGetDirCount(mds, uuid, dirname, callback);
			}
		], function (err, results) {
			cb(err);
		});
	}

	/* Each thumbnail upload will create two parent directories, as it does in SPC */
	function simulateThumbnailUpload(objectPath, uuid, callback) {
		var parentDir = mod_path.dirname(objectPath);
		var grandParentDir = mod_path.dirname(parentDir);

		mod_vasync.waterfall([
			function (callback) {
				mdsOpSimulatePutDirectory(grandParentDir, uuid, callback);
			},
			function (callback) {
				mdsOpSimulatePutDirectory(parentDir, uuid, callback);
			},
			function (callback) {
				mdsOpSimulatePutObject(objectPath, uuid, callback);
			}
		], function (err) {
			callback(err);
		});
	}

	/* Generate uuid and parameters for thumbnail upload. */
	function uploadThumbnail(callback) {
		var uuid = mod_uuid.v4();
		var uuid_components = uuid.split('-');
		
		var dirOne = mod_path.join(mds.mds_path_large, uuid_components[0].substr(0,4)) 
		var dirTwo = mod_path.join(dirOne, uuid_components[1]);
		var obj = mod_path.join(dirTwo, uuid);

		simulateThumbnailUpload(obj, uuid, function (err) {
			callback(err, uuid, obj);
		});
	}

	op.mp_pipeline = mod_vasync.waterfall([
		function (callback) {
			uploadThumbnail(callback);
		},
		function (_, _, callback) {
			uploadThumbnail(callback);
		},
		function (_, _, callback) {
			uploadThumbnail(callback);
		},
		function (lastUuid, lastThumbnail, callback) {
			mdsGetObject(mds, lastUuid, lastThumbnail, callback);
		}
	], function (err) {
		var latms;

		mod_assertplus.ok(mds.mds_nops_started >= mds.mds_nops_done);
		mod_assertplus.ok(mds.mds_nops_started - mds.mds_nops_done
		    <= mds.mds_max_concurrency);
		mod_assertplus.ok(mds.mds_pending[uuid] == op);

		op.mp_elapsed = process.hrtime(op.mp_start_hrtime);
		mds.mds_nops_done++;
		mds.mds_c_ndone.increment();
		delete (mds.mds_pending[uuid]);

		latms = mod_jsprim.hrtimeMillisec(op.mp_elapsed);
		mds.mds_hist_op.observe(latms);
		mds.mds_log.debug({
		    'failed': err ? true : false,
		    'latency': latms,
		    'uuid': uuid,
		    'nstarted': mds.mds_nops_started,
		    'ndone': mds.mds_nops_done,
		    'nfailures': mds.mds_nops_fail
		}, 'operation complete');

		if (err) {
			mds.mds_nops_fail++;
			mds.mds_c_nfail.increment();
			err = new VError(err, 'operation failed');
			mds.mds_log.warn(err);
		}

		mdsShovelOperation(mds);
	});
}

/*
 * Retrieves metadata for the object at "path".  In dry-run mode, this does
 * nothing.
 */
function mdsGetObject(mds, reqid, path, callback)
{
	mdsDoOp(mds, 'get', {
		'key': path,
		'requestId': reqid
	}, function (err) {
		if (err &&
		    VError.findCauseByName(err, 'ObjectNotFoundError')
		    !== null) {

			err = null;
		}
		callback(err);
	});
}

/*
 * Retrieves the number of entries in the given "path" directory.  In dry-run
 * mode this does nothing.
 */
function mdsGetDirCount(mds, reqid, path, callback)
{
	mdsDoOp(mds, 'count', {
		'directory': path,
		'requestId': reqid
	}, function (err) {
		if (err &&
		    VError.findCauseByName(err, 'ObjectNotFoundError')
		    !== null) {

			err = null;
		}
		callback(err);
	});
}

/*
 * Creates metadata for a directory at "path".  In dry-run mode, this does
 * nothing.
 */
function mdsCreateDirectory(mds, reqid, path, callback)
{
	mdsDoOp(mds, 'mkdir', {
	    'dirname': mod_path.dirname(path),
	    'key': path,
	    'headers': {},
	    'mtime': Date.now(),
	    'owner': 'e9c7b8f7-f51a-43ed-a159-f109da7d3162',
	    'requestId': reqid,
	    'roles': [],
	    'type': 'directory',
	    '_etag': undefined
	}, function (err) {
		if (err && VError.hasCauseWithName(err, 'EtagConflictError')) {
			err = null;
		}

		callback(err);
	});
}

/*
 * Creates metadata for an object at "path".  In dry-run mode, this does
 * nothing.
 */
function mdsCreateObject(mds, reqid, path, callback)
{
	mdsDoOp(mds, 'put', {
	    'dirname': mod_path.dirname(path),
	    'key': path,
	    'headers': {},
	    'mtime': Date.now(),
	    'owner': 'e9c7b8f7-f51a-43ed-a159-f109da7d3162',
	    'requestId': reqid,
	    'roles': [],
	    'type': 'directory',
	    '_etag': undefined,
	    'contentLength': 0,
	    'contentMD5': 'invalid-md5-sum',
	    'contentType': 'application/octet-stream',
	    'objectId': reqid,
	    'sharks': [ {
		'datacenter': 'invalid_dc',
		'manta_storage_id': 'invalid_shark'
	    } ]
	}, callback);
}

/*
 * Lowest-level function for interacting with Manta metadata. The caller
 * provides "metadata", the actual metadata, which should be valid metadata for
 * a directory or object.  "opname" should be "mkdir", "put", "count", or
 * "get" -- it's used for logging and determining which node-moray function
 * to call to fulfill the request.
 */
function mdsDoOp(mds, opname, metadata, callback)
{
	if (mds.mds_dryrun) {
		mds.mds_log.debug({
		    'op': opname,
		    'path': metadata.key,
		    'reqid': metadata.requestId
		}, 'skipping operation (dry run)');

		/*
		 * We throttle the dry run, since one of the main purposes is to
		 * validate the concurrency of the program.
		 */
		setTimeout(callback, 100);
		return;
	}

	function done(err) {
		var latms = mod_jsprim.hrtimeMillisec(process.hrtime(start));
		mds.mds_hist_md.observe(latms, {
		    'operation': opname
		});
		mds.mds_c_op_done.increment({
		    'operation': opname
		});

		if (err) {
			err = new VError(err, '%s "%s"', opname, metadata.key);
		}

		callback(err);
	}

	var start = process.hrtime();
	switch (opname) {
		case 'count':
			mds.mds_mdclient.getDirectoryCount(metadata, done);
			break;
		case 'get':
			mds.mds_mdclient.getMetadata(metadata, done);
			break;
		default:
			mds.mds_mdclient.putMetadata(metadata, done);
			break;
	}

}

/*
 * Starts an HTTP server for Artedi-based metrics.
 */
function mdsArtediStart(mds, callback)
{
	mds.mds_server = mod_http.createServer(function (request, response) {
		mdsArtediHandleRequest(mds, request, response);
	});

	mds.mds_server.listen(mds.mds_port, function () {
		mds.mds_log.info(
		    { 'address': mds.mds_server.address() },
		    'listening (artedi server)');
		callback();
	});
}

function mdsArtediHandleRequest(mds, request, response)
{
	if (request.url != '/metrics') {
		response.writeHead(404, { 'connection': 'close' });
		response.end();
		return;
	}

	if (request.method != 'GET') {
		response.writeHead(405, { 'connection': 'close' });
		response.end();
		return;
	}

	mds.mds_artedi.collect(mod_artedi.FMT_PROM, function (err, metrics) {
		if (err) {
			response.writeHead(500, { 'connection': 'close' });
			mds.mds_log.warn(err, 'failed to collect metrics');
			response.end();
			return;
		}

		request.on('end', function () {
			response.writeHead(200, {
			    'Content-Type': 'text/plain; version=0.0.4'
			});
			response.end(metrics);
		});

		request.resume();
	});
}

main();
