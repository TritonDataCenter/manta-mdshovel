#!/usr/bin/env node
/* vim: set ft=javascript: */
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

/*
 * Copyright (c) 2017, Joyent, Inc.
 */

/*
 * mdshovel: stress-test for Manta metadata
 */

var mod_artedi = require('artedi');
var mod_assertplus = require('assert-plus');
var mod_bunyan = require('bunyan');
var mod_cmdutil = require('cmdutil');
var mod_fs = require('fs');
var mod_getopt = require('posix-getopt');
var mod_jsprim = require('jsprim');
var mod_boray = require('boray');
var mod_http = require('http');
var mod_path = require('path');
var mod_uuid = require('node-uuid');
var mod_vasync = require('vasync');
var VError = require('verror');

var mdsUsageMessage = [
    'Generates metadata according to specified configuration.'
].join('');

/*
 * This stress tester generates metadata similar to known workloads as follows:
 * for each operation (simulating an application-level operation), we generate a
 * uuid, then we create a directory for the operation under "largeDirectory",
 * and we create a tree of directories under "smallDirectoryRoot".  We complete
 * operations with concurrency "concurrency".
 */
var mdsConfigSchema = {
    'type': 'object',
    'properties': {
	'concurrency': {
	    'type': 'number',
	    'required': true,
	    'minimum': 1,
	    'maximum': 8192
	},
	'artediPort': {
	    'type': 'number',
	    'required': true,
	    'minimum': 1,
	    'maximum': 65535
	}
    }
};

function main()
{
	var parser, option, argv;
	var log, cfgfile, dryrun, nobjects;

	log = new mod_bunyan({
	    'name': 'mdshovel',
	    'level': process.env['LOG_LEVEL'] || 'info'
	});

	mod_cmdutil.configure({
	    'synopses': [ 'CONFIG_FILE' ],
	    'usageMessage': mdsUsageMessage
	});

	dryrun = false;
	nobjects = Infinity;
	parser = new mod_getopt.BasicParser('no:', process.argv);
	while ((option = parser.getopt()) !== undefined) {
		switch (option.option) {
		case 'n':
			dryrun = true;
			break;
		case 'o':
			nobjects = mod_jsprim.parseInteger(option.optarg);
			break;

		default:
			/* error message already emitted by getopt */
			mod_assertplus.equal('?', option.option);
			mod_cmdutil.usage();
			break;
		}
	}

	argv = process.argv.slice(parser.optind());
	if (argv.length != 1) {
		mod_cmdutil.usage('expected exactly one argument');
	}

	cfgfile = argv[0];
	mdsConfigLoadFromFile({
	    'log': log,
	    'dryRun': dryrun,
	    'nobjects': nobjects,
	    'filename': cfgfile
	}, function (err, mds) {
		if (err) {
			mod_cmdutil.fail(err);
		}

		mdsShovel(mds);
	});
}

/*
 * Given a filename in "args.filename", initializes program state based on the
 * configuration in that file.
 */
function mdsConfigLoadFromFile(args, callback)
{
	var log, filename, dryrun, nobjects;

	mod_assertplus.object(args, 'args');
	mod_assertplus.string(args.filename, 'args.filename');
	mod_assertplus.object(args.log, 'args.log');
	mod_assertplus.bool(args.dryRun, 'args.dryRun');
	mod_assertplus.number(args.nobjects, 'args.nobjects');

	filename = args.filename;
	log = args.log;
	dryrun = args.dryRun;
	nobjects = args.nobjects;

	mod_fs.readFile(filename, function (err, filebytes) {
		var json, error, suffix;

		if (err) {
			callback(new VError(err, 'read "%s"', filename));
			return;
		}

		try {
			json = JSON.parse(filebytes.toString('utf8'));
		} catch (ex) {
			callback(new VError(ex, 'parse "%s"', filename));
			return;
		}

		error = mod_jsprim.validateJsonObject(mdsConfigSchema, json);
		if (error instanceof Error) {
			callback(new VError(error, 'validate "%s"', filename));
			return;
		}

		callback(null, new Mds({
		    'filename': filename,
		    'dryRun': dryrun,
		    'nobjects': nobjects,
		    'log': log,
		    'configRaw': json
		}));
	});
}

/*
 * Stores the configuration and runtime state for the `mdshovel` operation.
 * By the time we call the constructor, the JSON must already have been
 * validated.
 */
function Mds(args)
{
	mod_assertplus.object(args, 'args');
	mod_assertplus.string(args.filename, 'args.filename');
	mod_assertplus.object(args.log, 'args.log');
	mod_assertplus.object(args.configRaw, 'args.configRaw');
	mod_assertplus.bool(args.dryRun, 'args.dryRun');
	mod_assertplus.number(args.nobjects, 'args.nobjects');

	/* static configuration */
	this.mds_config_filename = args.filename;
	this.mds_config_raw = args.configRaw;
	this.mds_max_concurrency = args.configRaw.concurrency;
	this.mds_port = args.configRaw.artediPort;
	this.mds_vnodes = args.configRaw.vnodes;
	this.mds_dryrun = args.dryRun;
	this.mds_nobjects_target = args.nobjects;

	/* runtime state */

	/* bunyan logger */
	this.mds_log = args.log;
	/* artedi collector */
	this.mds_artedi = mod_artedi.createCollector();
	/* http server for artedi */
	this.mds_server = null;
	/* metadata tier client (from libmanta) */
	this.mds_mdclient = null;
	/* timestamp when the metadata client became ready */
	this.mds_mdclient_ready = null;
	/* pending operations */
	this.mds_pending = {};

	/*
	 * Artedi-based metrics
	 */
	this.mds_c_nstarted = this.mds_artedi.counter({
	    'name': 'nstarted',
	    'help': 'count of composite operations started'
	});
	this.mds_c_ndone = this.mds_artedi.counter({
	    'name': 'ndone',
	    'help': 'count of composite operations completed ' +
		'(including failures)'
	});
	this.mds_c_nfail = this.mds_artedi.counter({
	    'name': 'nfail',
	    'help': 'count of composite operations that have failed'
	});
	this.mds_c_nsuccess = this.mds_artedi.counter({
	    'name': 'nsuccess',
	    'help': 'count of composite operations that have succeeded'
	});
	this.mds_c_op_done = this.mds_artedi.counter({
	    'name': 'nopdone',
	    'help': 'count of discrete metadata operations finished'
	});
	this.mds_hist_op = this.mds_artedi.histogram({
	    'name': 'composite_latency_ms',
	    'help': 'latency of composite operations'
	});
	this.mds_hist_md = this.mds_artedi.histogram({
	    'name': 'md_latency_ms',
	    'help': 'latency of metadata operations'
	});

	/* simple counters */
	this.mds_nops_started = 0;	/* operations started */
	this.mds_nops_done = 0;		/* operations completed */
	this.mds_nops_fail = 0;		/* operations failed */
}

/*
 * Kicks off the `mdshovel` workload.
 */
function mdsShovel(mds)
{
	mod_assertplus.strictEqual(mds.mds_mdclient, null);

	mds.mds_log.info({
	    'configFilename': mds.mds_config_filename,
	    'configRaw': mds.mds_config_raw,
	    'dryRun': mds.mds_dryrun
	}, 'init');

	mds.mds_config_raw.metadataService.log = mds.mds_log;
	mds.mds_config_raw.metadataService.crc_mode = 0x3;
	mds.mds_mdclient = mod_boray.createClient(
	    mds.mds_config_raw.metadataService
	);

	mds.mds_mdclient.on('error', function onMetadataClientError(err) {
		mod_cmdutil.fail(new VError(
		    err, 'fatal error from metadata client'));
	});

	mds.mds_mdclient.on('connect', function onMetadataClientConnect() {
		var i, max;

		mds.mds_mdclient_ready = new Date();
		mds.mds_log.info('connected to the metadata tier');

		mdsArtediStart(mds, function (err) {
			if (err) {
				mod_cmdutil.fail(err);
			}

			mod_assertplus.notStrictEqual(mds.mds_mdclient, null);
			max = mds.mds_max_concurrency;
			mod_assertplus.number(max);
			mod_assertplus.ok(max > 0);
			for (i = 0; i < mds.mds_max_concurrency; i++) {
				mdsShovelOperation(mds);
			}
		});
	});
}

/*
 * Completes one application-level operation, as described above.
 */
function mdsShovelOperation(mds)
{
	var op, uuid;

	/*
	 * The workload that we're simulating uses general uuids, but shards
	 * them over 16 metadata directories based on the first character of the
	 * uuid.  To reproduce the problem faster, we want to concentrate all of
	 * our work on one of these directories, as though all uuids started
	 * with the same letter.  Since we're faking up metadata anyway, it
	 * doesn't matter if our uuid really starts with that letter, but it
	 * will be a little less confusing this way.
	 */
	uuid = mod_uuid.v4();
	mod_assertplus.uuid(uuid);

	op = {
	    'mp_name': uuid,
	    'mp_pipeline': null,
	    'mp_start_walltime': new Date(),
	    'mp_start_hrtime': process.hrtime(),
	    'mp_elapsed': null
	};

	mds.mds_pending[uuid] = op;
	mds.mds_nops_started++;
	mds.mds_c_nstarted.increment();
	mds.mds_log.debug({
	    'uuid': uuid,
	    'nstarted': mds.mds_nops_started,
	    'ndone': mds.mds_nops_done,
	    'nfailures': mds.mds_nops_fail
	}, 'beginning operation');

	op.mp_pipeline = mod_vasync.waterfall([
	    function mdsOpCreateBucketObject(callback) {
		var vnode = mds.mds_vnodes[
		    Math.floor(Math.random() * mds.mds_vnodes.length)];
		mdsCreateBucketObject(mds, uuid, uuid, vnode, callback);
	    }
	], function (err) {
		var latms;

		mod_assertplus.ok(mds.mds_nops_started >= mds.mds_nops_done);
		mod_assertplus.ok(mds.mds_nops_started - mds.mds_nops_done
		    <= mds.mds_max_concurrency);
		mod_assertplus.ok(mds.mds_pending[uuid] == op);

		op.mp_elapsed = process.hrtime(op.mp_start_hrtime);
		mds.mds_nops_done++;
		mds.mds_c_ndone.increment();
		delete (mds.mds_pending[uuid]);

		latms = mod_jsprim.hrtimeMillisec(op.mp_elapsed);
		mds.mds_hist_op.observe(latms);
		mds.mds_log.debug({
		    'failed': err ? true : false,
		    'latency': latms,
		    'uuid': uuid,
		    'nstarted': mds.mds_nops_started,
		    'ndone': mds.mds_nops_done,
		    'nfailures': mds.mds_nops_fail
		}, 'operation complete');

		if (err) {
			mds.mds_nops_fail++;
			mds.mds_c_nfail.increment();
			err = new VError(err, 'operation failed');
			mds.mds_log.warn(err);
		} else {
			mds.mds_c_nsuccess.increment();

			if (mds.mds_c_nsuccess.getValue() ===
			    mds.mds_nobjects_target) {
				mdsFinish(mds);
			}
		}

		mdsShovelOperation(mds);
	});
}

function mdsCreateBucketObject(mds, reqid, name, vnode, callback)
{
	mdsDoOp(mds, 'put', {
	    'owner': 'e9c7b8f7-f51a-43ed-a159-f109da7d3162',
	    'bucket_id': '4c59d6c4-d495-11e9-b86b-4fcb99cb2c8a',
	    'key': mod_uuid.v4(),
	    'name': name,
	    'vnode': vnode,
	    'requestId': reqid,
	    'content_length': 0,
	    'content_md5': 'NjA0NTYyYTktMzE5Yi00Mzk1LTgzYzEtMjA2MDlhNjcwNTY0',
	    'content_type': 'application/octet-stream',
	    'headers': {},
	    'sharks': [ {
		'datacenter': 'invalid-0',
		'manta_storage_id': '0.invalid'
	    }, {
		'datacenter': 'invalid-1',
		'manta_storage_id': '1.invalid'
	    } ],
	    'props': {},
	    'log': mds.mds_log
	}, callback);
}

/*
 * Lowest-level function for interacting with Manta metadata. The caller
 * provides "metadata", the actual metadata, which should be valid metadata for
 * a directory or object.  "opname" should be "mkdir", "put", "count", or
 * "get" -- it's used for logging and determining which node-moray function
 * to call to fulfill the request.
 */
function mdsDoOp(mds, opname, metadata, callback)
{
	if (mds.mds_dryrun) {
		mds.mds_log.debug({
		    'op': opname,
		    'path': metadata.key,
		    'reqid': metadata.requestId
		}, 'skipping operation (dry run)');

		/*
		 * We throttle the dry run, since one of the main purposes is to
		 * validate the concurrency of the program.
		 */
		setTimeout(callback, 100);
		return;
	}

	var start = process.hrtime();
	mds.mds_mdclient.createObject(metadata.owner, metadata.bucket_id,
	    metadata.name, metadata.key, metadata.content_length,
	    metadata.content_md5, metadata.content_type, metadata.headers,
	    metadata.sharks, metadata.props, metadata.vnode,
	    metadata.requestId, function (err) {
		var latms = mod_jsprim.hrtimeMillisec(process.hrtime(start));
		mds.mds_hist_md.observe(latms, {
		    'operation': opname
		});
		mds.mds_c_op_done.increment({
		    'operation': opname
		});

		if (err) {
			err = new VError(err, '%s "%s"', opname, metadata.key);
		}

		callback(err);
	});
}

function mdsFinish(mds) {
	mds.mds_log.info({
	    'nobjects': mds.mds_c_nsuccess.getValue()
	}, 'finish');
	process.exit();
}

/*
 * Starts an HTTP server for Artedi-based metrics.
 */
function mdsArtediStart(mds, callback)
{
	mds.mds_server = mod_http.createServer(function (request, response) {
		mdsArtediHandleRequest(mds, request, response);
	});

	mds.mds_server.listen(mds.mds_port, function () {
		mds.mds_log.info(
		    { 'address': mds.mds_server.address() },
		    'listening (artedi server)');
		callback();
	});
}

function mdsArtediHandleRequest(mds, request, response)
{
	if (request.url != '/metrics') {
		response.writeHead(404, { 'connection': 'close' });
		response.end();
		return;
	}

	if (request.method != 'GET') {
		response.writeHead(405, { 'connection': 'close' });
		response.end();
		return;
	}

	mds.mds_artedi.collect(mod_artedi.FMT_PROM, function (err, metrics) {
		if (err) {
			response.writeHead(500, { 'connection': 'close' });
			mds.mds_log.warn(err, 'failed to collect metrics');
			response.end();
			return;
		}

		request.on('end', function () {
			response.writeHead(200, {
			    'Content-Type': 'text/plain; version=0.0.4'
			});
			response.end(metrics);
		});

		request.resume();
	});
}

main();
